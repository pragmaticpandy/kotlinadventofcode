// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2015`

import com.github.h0tk3y.betterParse.combinators.and
import com.github.h0tk3y.betterParse.combinators.map
import com.github.h0tk3y.betterParse.combinators.skip
import com.github.h0tk3y.betterParse.combinators.use
import com.github.h0tk3y.betterParse.grammar.Grammar
import com.github.h0tk3y.betterParse.grammar.parseToEnd
import com.github.h0tk3y.betterParse.lexer.literalToken
import com.github.h0tk3y.betterParse.lexer.regexToken
import com.github.h0tk3y.betterParse.parser.Parser
import kotlinadventofcode.Day
import kotlin.math.max

class `2015-21` : Day {

    data class Weapon(val name: String, val cost: Int, val damage: Int)

    val weapons = setOf(
        Weapon("Dagger", 8, 4),
        Weapon("Shortsword", 10, 5),
        Weapon("Warhammer", 25, 6),
        Weapon("Longsword", 40, 7),
        Weapon("Greataxe", 74, 8)
    )

    data class Armor(val name: String, val cost: Int, val defence: Int)

    val armors = setOf(
        Armor("Leather", 13, 1),
        Armor("Chainmail", 31, 2),
        Armor("Splintmail", 53, 3),
        Armor("Bandedmail", 75, 4),
        Armor("Platemail", 102, 5),
        null
    )

    data class Ring(val cost: Int, val damage: Int, val defence: Int)

    val rings = setOf(
        Ring(25, 1, 0),
        Ring(50, 2, 0),
        Ring(100, 3, 0),
        Ring(20, 0, 1),
        Ring(40, 0, 2),
        Ring(80, 0, 3)
    )

    interface Fighter {
        val hp: Int
        val damage: Int
        val defence: Int

        fun canBeat(other: Fighter) : Boolean {
            var thisHp = hp
            var otherHp = other.hp
            while (true) {
                otherHp -= max(1, damage - other.defence)
                if (otherHp <= 0) return true
                thisHp -= max(1, other.damage - defence)
                if (thisHp <= 0) return false
            }
        }
    }

    private val heroHp = 100

    data class Hero(
        override val hp: Int,
        val weapon: Weapon,
        val armor: Armor?,
        val rings: Set<Ring>
    ) : Fighter {
        override val damage = weapon.damage + rings.sumBy { it.damage }
        override val defence = (armor?.defence ?: 0) + rings.sumBy { it.defence }
        val cost = weapon.cost + (armor?.cost ?: 0) + rings.sumBy { it.cost }
    }

    private fun parse(input: String): Fighter {
        val grammar = object: Grammar<Fighter>() {
            val newline by literalToken("\n")
            val hpToken by literalToken("Hit Points: ")
            val damageToken by literalToken("Damage: ")
            val armorToken by literalToken("Armor: ")

            val numToken by regexToken("""[0-9]+""")

            val num by numToken use { text.toInt() }

            override val rootParser: Parser<Fighter> by (skip(hpToken) and num and skip(newline) and
                skip(damageToken) and num and skip(newline) and
                skip(armorToken) and num) map {
                    object : Fighter {
                        override val hp: Int = it.t1
                        override val damage: Int = it.t2
                        override val defence: Int = it.t3
                    }
                }
        }

        return grammar.parseToEnd(input)
    }

    private fun getRingCombos(): Set<Set<Ring>> {
        val sets: MutableSet<Set<Ring>> = rings.map { setOf(it) }.toMutableSet()
        sets.add(setOf())
        for (ring in rings) {
            for (secondRing in rings.minus(ring)) {
                sets.add(setOf(ring, secondRing))
            }
        }

        return sets
    }

    private fun getArmorAndRingCombos(): Set<Pair<Armor?, Set<Ring>>> {
        return getRingCombos().flatMap { rings -> armors.map { armor -> armor to rings } }.toSet()
    }

    private fun getLoadouts(): Set<Hero> {
        val armorAndRingCombos = getArmorAndRingCombos()
        return weapons
            .flatMap { weapon ->
                armorAndRingCombos.map { Hero(heroHp, weapon, it.first, it.second) }
            }
            .toSet()
    }

    /**
     * After verifying your solution on the AoC site, run `./ka continue` to add a test for it.
     */
    override fun runPartOneNoUI(input: String): String {
        val boss = parse(input)
        return getLoadouts().filter { it.canBeat(boss) }.minOf { it.cost }.toString()
    }

    /**
     * After verifying your solution on the AoC site, run `./ka continue` to add a test for it.
     */
    override fun runPartTwoNoUI(input: String): String {
        val boss = parse(input)
        return getLoadouts().filter { !it.canBeat(boss) }.maxOf { it.cost }.toString()
    }

    override val defaultInput = """Hit Points: 104
Damage: 8
Armor: 1"""
}