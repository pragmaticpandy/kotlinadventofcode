// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2015`

import com.github.h0tk3y.betterParse.combinators.and
import com.github.h0tk3y.betterParse.combinators.map
import com.github.h0tk3y.betterParse.combinators.separatedTerms
import com.github.h0tk3y.betterParse.combinators.skip
import com.github.h0tk3y.betterParse.grammar.Grammar
import com.github.h0tk3y.betterParse.grammar.parseToEnd
import com.github.h0tk3y.betterParse.lexer.literalToken
import com.github.h0tk3y.betterParse.lexer.regexToken
import com.github.h0tk3y.betterParse.parser.Parser
import com.google.common.util.concurrent.RateLimiter
import kotlinadventofcode.Day
import java.time.Duration
import java.time.Instant
import java.util.*
import kotlin.Comparator
import kotlin.collections.ArrayDeque
import kotlin.math.ceil

class `2015-19` : Day {

    data class Molecule(val molecule: String): CharSequence by molecule {

        /**
         * Get all possible new molecules after a single replacement of the given replacement.
         */
        private fun getNextMolecules(replacement: Replacement): Collection<Molecule> {
            return getReplacedMolecules(replacement.from.molecule, replacement.to.molecule)
        }

        /**
         * Gets all possible previous molecules before a single replacement of the given replacement.
         */
        private fun getPreviousMolecules(replacement: Replacement): Collection<Molecule> {
            return getReplacedMolecules(replacement.to.molecule, replacement.from.molecule)
        }

        private fun getReplacedMolecules(from: String, to: String): Collection<Molecule> {
            val newMolecules = mutableSetOf<Molecule>()
            var searchStartIndex = 0
            while (searchStartIndex < molecule.length) {
                val matchIndex = molecule
                    .findAnyOf(listOf(from), searchStartIndex)
                    ?.first
                    ?: break // if there is no match

                newMolecules += Molecule(
                    molecule.replaceRange(matchIndex, matchIndex + from.length, to))

                searchStartIndex = matchIndex + 1
            }

            return newMolecules
        }

        /**
         * Get all possible new molecules after a single replacement of one of the given replacements.
         */
        fun getAllNextMolecules(replacements: Collection<Replacement>): Collection<Molecule> {
            return replacements.flatMap { getNextMolecules(it) }.toSet()
        }

        /**
         * Get all possible molecules before a single replacement of one of the given replacements.
         */
        fun getAllPreviousMolecules(replacements: Collection<Replacement>): Collection<Molecule> {
            return replacements.flatMap { getPreviousMolecules(it) }.toSet()
        }
    }

    data class Replacement(val from: Molecule, val to: Molecule)

    private fun parse(input: String): Pair<List<Replacement>, Molecule> {
        val grammar = object: Grammar<Pair<List<Replacement>, Molecule>>() {
            val replacementToken by literalToken(" => ")
            val newline by literalToken("\n")
            val moleculeToken by regexToken("[A-Za-z]+")

            val molecule by moleculeToken map { Molecule(it.text) }
            val replacement by (molecule and skip(replacementToken) and molecule) map {
                Replacement(it.t1, it.t2)
            }

            val replacements by separatedTerms(replacement, newline)

            override val rootParser: Parser<Pair<List<Replacement>, Molecule>> by
                (replacements and skip(newline) and skip(newline) and molecule) map { it.t1 to it.t2 }
        }

        return grammar.parseToEnd(input)
    }

    /**
     * After verifying your solution on the AoC site, run `./ka continue` to add a test for it.
     */
    override fun runPart1(input: String): String {
        val (replacements, molecule) = parse(input)
        return molecule.getAllNextMolecules(replacements).size.toString()
    }

    /**
     * This was super annoying because to write an algorithm that runs in a reasonable amount of
     * time, you had to examine the input file and determine a pattern within the replacements. This
     * was not ever previously required in any AoC problems, and is kinda not expected since the
     * point of an algorithm is to run it on any input in the described domain—i.e. the domain was
     * not fully described by the problem statement. So, based on the problem statement, I wrote an
     * A* search before realizing that even that wouldn't run in a reasonable amount of time.
     * Anyway, the nature of the input is that it's actually a grammar, and there is only one
     * number of steps possible—i.e. you don't need to do anything special to figure out which
     * solution uses the least number of replacements.
     * Here, we just randomly guess to find a path.
     */
    override fun runPart2(input: String): String {
        val (replacements, endMolecule) = parse(input)
        val startMolecule = Molecule("e")

        var molecule = endMolecule
        var numReplacements = 0
        while (molecule != startMolecule) {
            // If there are no possible replacements, just start over and try again.
            molecule = molecule.getAllPreviousMolecules(replacements).randomOrNull() ?: return runPart2(input)
            numReplacements++
        }

        return numReplacements.toString()
    }

    override val defaultInput = """Al => ThF
Al => ThRnFAr
B => BCa
B => TiB
B => TiRnFAr
Ca => CaCa
Ca => PB
Ca => PRnFAr
Ca => SiRnFYFAr
Ca => SiRnMgAr
Ca => SiTh
F => CaF
F => PMg
F => SiAl
H => CRnAlAr
H => CRnFYFYFAr
H => CRnFYMgAr
H => CRnMgYFAr
H => HCa
H => NRnFYFAr
H => NRnMgAr
H => NTh
H => OB
H => ORnFAr
Mg => BF
Mg => TiMg
N => CRnFAr
N => HSi
O => CRnFYFAr
O => CRnMgAr
O => HP
O => NRnFAr
O => OTi
P => CaP
P => PTi
P => SiRnFAr
Si => CaSi
Th => ThCa
Ti => BP
Ti => TiTi
e => HF
e => NAl
e => OMg

ORnPBPMgArCaCaCaSiThCaCaSiThCaCaPBSiRnFArRnFArCaCaSiThCaCaSiThCaCaCaCaCaCaSiRnFYFArSiRnMgArCaSiRnPTiTiBFYPBFArSiRnCaSiRnTiRnFArSiAlArPTiBPTiRnCaSiAlArCaPTiTiBPMgYFArPTiRnFArSiRnCaCaFArRnCaFArCaSiRnSiRnMgArFYCaSiRnMgArCaCaSiThPRnFArPBCaSiRnMgArCaCaSiThCaSiRnTiMgArFArSiThSiThCaCaSiRnMgArCaCaSiRnFArTiBPTiRnCaSiAlArCaPTiRnFArPBPBCaCaSiThCaPBSiThPRnFArSiThCaSiThCaSiThCaPTiBSiRnFYFArCaCaPRnFArPBCaCaPBSiRnTiRnFArCaPRnFArSiRnCaCaCaSiThCaRnCaFArYCaSiRnFArBCaCaCaSiThFArPBFArCaSiRnFArRnCaCaCaFArSiRnFArTiRnPMgArF"""
}