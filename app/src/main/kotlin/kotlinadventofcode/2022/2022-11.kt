// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2022`

import com.github.h0tk3y.betterParse.combinators.*
import com.github.h0tk3y.betterParse.grammar.*
import com.github.h0tk3y.betterParse.lexer.*
import kotlinadventofcode.Day
import java.math.BigInteger

class `2022-11` : Day {

    override fun runPart1(input: String): String {
        return run(input, 20, divideByThree = true)
    }

    override fun runPart2(input: String): String {
        return run(input, 10_000, divideByThree = false)
    }

    fun run(input: String, iterations: Int, divideByThree: Boolean): String {
        val monkeys = parse(input).associateBy { it.id }.toMutableMap()
        val inspectionsById = monkeys.keys.associateWith { 0 }.toMutableMap()

        /**
         * To keep the item worry levels small, we will regularly reset item's worry level to
         * itself mod the product of all the monkey's divisors.
         * Monkeys only test divisibility, so as long as the mod divisor is a product of all the
         * divisors that will be checked, taking this mod will not affect the results of any
         * individual divisor, as the amount subtracted from the worry level will always be a
         * multiple of every monkey's divisor.
         */
        val productOfDivisors =
            monkeys.values.map { it.divisor }.reduce { total, next -> next * total }.toBigInteger()

        repeat(iterations) {
            for (id in monkeys.keys.sorted()) {
                var monkey = monkeys[id]!!
                while (monkey.items.isNotEmpty()) {
                    inspectionsById[id] = inspectionsById[id]!! + 1

                    val newItem =
                        monkey.operation
                            .call(monkey.items.first())
                            .divide((if (divideByThree) 3 else 1).toBigInteger())
                            .mod(productOfDivisors)

                    if (newItem isDivisibleBy monkey.divisor.toBigInteger())
                        monkeys[monkey.trueTarget] =
                            monkeys[monkey.trueTarget]!!.newMonkeyAfterCatching(newItem)
                    else
                        monkeys[monkey.falseTarget] =
                            monkeys[monkey.falseTarget]!!.newMonkeyAfterCatching(newItem)

                    monkey = monkey.newMonkeyAfterThrowingFirst()
                }

                monkeys[id] = monkey
            }
        }

        return inspectionsById.values
            .sorted()
            .takeLast(2)
            .map { it.toBigInteger() }
            .reduce { total, next -> next.multiply(total) }
            .toString()
    }

    private val isDivisibleByMap: MutableMap<Pair<BigInteger, BigInteger>, Boolean> = mutableMapOf()
    private infix fun BigInteger.isDivisibleBy(divisor: BigInteger): Boolean {
        return isDivisibleByMap.getOrPut(this to divisor) {
            this.divideAndRemainder(divisor)[1] == 0.toBigInteger()
        }
    }

    /**
     * null operand indicates use the existing value
     */
    private data class Operation(
        val left: BigInteger?,
        val function: (first: BigInteger, second: BigInteger) -> BigInteger,
        val right: BigInteger?
    ) {
        fun call(old: BigInteger): BigInteger {
            return function(left ?: old, right ?: old)
        }
    }

    private data class Monkey(
        val id: Int,
        val items: List<BigInteger>,
        val operation: Operation,
        val divisor: Int,
        val trueTarget: Int,
        val falseTarget: Int
    ) {
        fun newMonkeyAfterCatching(item: BigInteger): Monkey {
            return Monkey(
                id,
                items + item,
                operation,
                divisor,
                trueTarget,
                falseTarget
            )
        }

        fun newMonkeyAfterThrowingFirst(): Monkey {
            return Monkey(
                id,
                items.subList(1, items.size),
                operation,
                divisor,
                trueTarget,
                falseTarget
            )
        }
    }

    private fun parse(input: String): List<Monkey> {
        val grammar = object : Grammar<List<Monkey>>() {

            /*
             * Tokens must be declared by themselvesâ€”i.e. they must be a declared property in this object.
             * Declaration order will be used in the case that multiple tokens match.
             */
            val nl by literalToken("\n")
            val commaLit by literalToken(",")
            val capitalMonkeyLit by literalToken("Monkey")
            val colonLit by literalToken(":")
            val s by literalToken(" ")
            val startingLit by literalToken("Starting")
            val itemsLit by literalToken("items")
            val operationLit by literalToken("Operation")
            val newLit by literalToken("new")
            val equalsLit by literalToken("=")
            val oldLit by literalToken("old")
            val asteriskLit by literalToken("*")
            val plusLit by literalToken("+")
            val testLit by literalToken("Test")
            val divisibleLit by literalToken("divisible")
            val byLit by literalToken("by")
            val ifLit by literalToken("If")
            val trueLit by literalToken("true")
            val falseLit by literalToken("false")
            val throwLit by literalToken("throw")
            val toLit by literalToken("to")
            val monkeyLit by literalToken("monkey")

            // regex tokens last
            val positiveIntRegex by regexToken("\\d+")

            /*
             * Intermediate parsers.
             */
            val positiveInt by positiveIntRegex use { text.toInt() }
            val monkeyId by skip(capitalMonkeyLit) and skip(s) and positiveInt and skip(colonLit)

            val startingItems by skip(2 times s) and skip(startingLit) and skip(s) and
                skip(itemsLit) and skip(colonLit) and skip(s) and
                separatedTerms(positiveInt, commaLit and s) map { intList ->
                    intList.map { it.toBigInteger() }
                }

            val multiply by asteriskLit map { { first: BigInteger, second: BigInteger -> first * second } }
            val add by plusLit map { { first: BigInteger, second: BigInteger -> first + second } }
            val oldOperand by oldLit map { null }

            val operation by skip(2 times s) and skip(operationLit) and skip(colonLit) and
                skip(s) and skip(newLit) and skip(s) and skip(equalsLit) and skip(s) and
                (oldOperand or positiveInt) and skip(s) and (multiply or add) and skip(s) and
                (oldOperand or positiveInt) map {
                    Operation(it.t1?.toBigInteger(), it.t2, it.t3?.toBigInteger())
                }

            val divisor by skip(2 times s) and skip(testLit) and skip(colonLit) and
                skip(s) and skip(divisibleLit) and skip(s) and skip(byLit) and skip(s) and
                positiveInt

            val trueTarget by skip(4 times s) and skip(ifLit) and skip(s) and
                skip(trueLit) and skip(colonLit) and skip(s) and skip(throwLit) and skip(s) and
                skip(toLit) and skip(s) and skip(monkeyLit) and skip(s) and positiveInt

            val falseTarget by skip(4 times s) and skip(ifLit) and skip(s) and
                skip(falseLit) and skip(colonLit) and skip(s) and skip(throwLit) and skip(s) and
                skip(toLit) and skip(s) and skip(monkeyLit) and skip(s) and positiveInt

            val monkey by monkeyId and skip(nl) and startingItems and skip(nl) and operation and
                skip(nl) and divisor and skip(nl) and trueTarget and skip(nl) and falseTarget map {
                    Monkey(it.t1, it.t2, it.t3, it.t4, it.t5, it.t6)
                }

            /*
             * Root parser.
             */
            override val rootParser by separatedTerms(monkey, 2 times nl)
        }

        return grammar.parseToEnd(input)
    }

    override val defaultInput = """Monkey 0:
  Starting items: 54, 89, 94
  Operation: new = old * 7
  Test: divisible by 17
    If true: throw to monkey 5
    If false: throw to monkey 3

Monkey 1:
  Starting items: 66, 71
  Operation: new = old + 4
  Test: divisible by 3
    If true: throw to monkey 0
    If false: throw to monkey 3

Monkey 2:
  Starting items: 76, 55, 80, 55, 55, 96, 78
  Operation: new = old + 2
  Test: divisible by 5
    If true: throw to monkey 7
    If false: throw to monkey 4

Monkey 3:
  Starting items: 93, 69, 76, 66, 89, 54, 59, 94
  Operation: new = old + 7
  Test: divisible by 7
    If true: throw to monkey 5
    If false: throw to monkey 2

Monkey 4:
  Starting items: 80, 54, 58, 75, 99
  Operation: new = old * 17
  Test: divisible by 11
    If true: throw to monkey 1
    If false: throw to monkey 6

Monkey 5:
  Starting items: 69, 70, 85, 83
  Operation: new = old + 8
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 7

Monkey 6:
  Starting items: 89
  Operation: new = old + 6
  Test: divisible by 2
    If true: throw to monkey 0
    If false: throw to monkey 1

Monkey 7:
  Starting items: 62, 80, 58, 57, 93, 56
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 6
    If false: throw to monkey 4"""
}