// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2022`

import com.github.h0tk3y.betterParse.combinators.*
import com.github.h0tk3y.betterParse.grammar.*
import com.github.h0tk3y.betterParse.lexer.*
import kotlinadventofcode.Day

class `2022-19` : Day {

    override fun runPart1(input: String): String {
        return parse(input).sumOf { it.quality(24) }.toString()
    }

    /**
     * After verifying your solution on the AoC site, run `./ka continue` to add a test for it.
     */
    override fun runPart2(input: String): String {

        /**
         * Perhaps use a parser (see example below) or just use the lines directly like so:
         * return input.lines().count { it == "what I'm looking for" }.toString()
         */

        throw Exception("2022 day 19 part 2 isn't yet implemented.")
    }

    private data class Amount(val ore: Int = 0, val clay: Int = 0, val obsidian: Int = 0) {
        init {
            if (ore < 0) throw Exception()
            if (clay < 0) throw Exception()
            if (obsidian < 0) throw Exception()
        }

        operator fun plus(other: Amount): Amount {
            return Amount(ore + other.ore, clay + other.clay, obsidian + other.obsidian)
        }

        operator fun minus(other: Amount): Amount {
            return Amount(ore - other.ore, clay - other.clay, obsidian - other.obsidian)
        }

        operator fun times(factor: Int): Amount {
            return Amount(ore * factor, clay * factor, obsidian * factor)
        }

        fun canAfford(cost: Amount):Boolean {
            return ore >= cost.ore && clay >= cost.clay && obsidian >= cost.obsidian
        }
    }

    private data class Blueprint(
        val id: Int,
        val oreRobotCost: Amount,
        val clayRobotCost: Amount,
        val obsidianRobotCost: Amount,
        val geodeRobotCost: Amount) {

        fun quality(minutes: Int): Int {
            return id * maxGeodes(minutes)
        }

        fun maxGeodes(minutes: Int): Int {
            data class State(
                val bank: Amount,
                val minsElapsed: Int,
                val geodesOpened: Int,
                val oreRobots: Int,
                val clayRobots: Int,
                val obsidianRobots: Int,
                val geodeRobots: Int) {

                init {

                    val numUniqueAffordableRobots =
                        listOf(
                                bank.canAfford(oreRobotCost),
                                bank.canAfford(clayRobotCost),
                                bank.canAfford(obsidianRobotCost),
                                bank.canAfford(geodeRobotCost))
                            .count { it }

                    if (numUniqueAffordableRobots > 1 ||
                        bank.canAfford(oreRobotCost * 2) ||
                        bank.canAfford(clayRobotCost * 2) ||
                        bank.canAfford(obsidianRobotCost * 2) ||
                        bank.canAfford(geodeRobotCost * 2)) {

                        throw Exception("didn't expect multiple buys to be possible")
                    }

                }

                /**
                 * todo do I need to handle the case where more than one robot is manufactured in a
                 * single minute?
                 */
                fun nextStates() {
                    val stateWithNoPurchases = State(
                        bank = bank.plus(Amount(ore = oreRobots, clay = clayRobots, obsidian = obsidianRobots)),
                        minsElapsed = minsElapsed + 1,
                        geodesOpened = geodesOpened + geodeRobots,
                        oreRobots = oreRobots,
                        clayRobots = clayRobots,
                        obsidianRobots = obsidianRobots,
                        geodeRobots = geodeRobots)

                    val result = mutableSetOf(stateWithNoPurchases)

                    //todo rest
                }
            }

            val startingState = State(
                bank = Amount(0, 0, 0),
                minsElapsed = 0,
                geodesOpened = 0,
                oreRobots = 1,
                clayRobots = 0,
                obsidianRobots = 0,
                geodeRobots = 0)

            val stack = mutableListOf(startingState)
            val seenStates = mutableSetOf(startingState)
            var stateWithMostGeodes = startingState
            while (stack.isNotEmpty()) {
                val state = stack.removeFirst()

                if (state.minsElapsed == minutes) {
                    stateWithMostGeodes = listOf(stateWithMostGeodes, state).maxBy { it.geodesOpened }
                } else {

                }
            }








            println("Computing maxGeodes")
            var bank = Amount(0,0,0)
            var minsElapsed = 0
            var geodesOpened = 0
            var numOreRobots = 1
            var numClayRobots = 0
            var numObsidianRobots = 0
            var numGeodeRobots = 0
            while (minsElapsed < minutes) {
                val robotCompletionCalls: MutableList<() -> Unit> = mutableListOf()



                if (bank.canAfford(geodeRobotCost)) {
                    bank = bank.minus(geodeRobotCost)
                    robotCompletionCalls += { numGeodeRobots++ }
                    println("bought geoode robot")
                }

                if (bank.canAfford(obsidianRobotCost)) {
                    bank = bank.minus(obsidianRobotCost)
                    robotCompletionCalls += { numObsidianRobots++ }
                    println("bought obsidian robot")
                }

                if (bank.canAfford(clayRobotCost)) {
                    bank = bank.minus(clayRobotCost)
                    robotCompletionCalls += { numClayRobots++ }
                    println("bought clay robot")
                }

                if (bank.canAfford(oreRobotCost)) {
                    bank = bank.minus(oreRobotCost)
                    robotCompletionCalls += { numOreRobots++ }
                    println("bought ore robot")
                }

                bank =
                    bank.plus(
                        Amount(
                            ore = numOreRobots,
                            clay = numClayRobots,
                            obsidian = numObsidianRobots))

                geodesOpened += numGeodeRobots

                robotCompletionCalls.forEach { it() }
                minsElapsed++
            }

            return geodesOpened
        }
    }

    private fun parse(input: String): List<Blueprint> {
        val grammar = object : Grammar<List<Blueprint>>() {

            /*
             * Tokens must be declared by themselvesâ€”i.e. they must be a declared property in this object.
             * Declaration order will be used in the case that multiple tokens match.
             */
            val nl by literalToken("\n")
            val blueprintLit by literalToken("Blueprint ")
            val oreRobotLit by literalToken(": Each ore robot costs ")
            val clayRobotLit by literalToken(". Each clay robot costs ")
            val obsidianRobotLit by literalToken(". Each obsidian robot costs ")
            val geodeRobotLit by literalToken(". Each geode robot costs ")
            val andLit by literalToken("and")

            val oreLit by literalToken("ore")
            val clayLit by literalToken("clay")
            val obsidianLit by literalToken("obsidian")

            val s by literalToken(" ")
            val p by literalToken(".")
            val positiveIntRegex by regexToken("\\d+")

            /*
             * Intermediate parsers.
             */
            val positiveInt by positiveIntRegex use { text.toInt() }
            val ore by positiveInt and skip(s) and skip(oreLit) map { Amount(ore = it) }
            val clay by positiveInt and skip(s) and skip(clayLit) map { Amount(clay = it) }
            val obsidian by positiveInt and skip(s) and skip(obsidianLit) map { Amount(obsidian = it) }
            val amount by separatedTerms(ore or clay or obsidian, s and andLit and s) map {
                it.reduce { acc, next -> acc + next }
            }

            val blueprint by skip(blueprintLit) and positiveInt and skip(oreRobotLit) and amount and
                skip(clayRobotLit) and amount and skip(obsidianRobotLit) and amount and
                skip(geodeRobotLit) and amount and skip(p) map { Blueprint(it.t1, it.t2, it.t3, it.t4, it.t5) }

            /*
             * Root parser.
             */
            override val rootParser by separatedTerms(blueprint, nl)
        }

        return grammar.parseToEnd(input)
    }


    override val defaultInput = """Blueprint 1: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 2: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 12 clay. Each geode robot costs 3 ore and 8 obsidian.
Blueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 16 obsidian.
Blueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 16 clay. Each geode robot costs 4 ore and 16 obsidian.
Blueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 3 ore and 12 obsidian.
Blueprint 6: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 3 ore and 11 obsidian.
Blueprint 7: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 19 clay. Each geode robot costs 2 ore and 9 obsidian.
Blueprint 8: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 18 clay. Each geode robot costs 2 ore and 11 obsidian.
Blueprint 9: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 9 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 10: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 4 ore and 17 obsidian.
Blueprint 11: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 9 clay. Each geode robot costs 2 ore and 9 obsidian.
Blueprint 12: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.
Blueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 14: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 20 clay. Each geode robot costs 4 ore and 16 obsidian.
Blueprint 15: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 20 clay. Each geode robot costs 2 ore and 12 obsidian.
Blueprint 16: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 13 clay. Each geode robot costs 2 ore and 10 obsidian.
Blueprint 17: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 2 ore and 19 obsidian.
Blueprint 18: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 19: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 4 ore and 8 obsidian.
Blueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 6 clay. Each geode robot costs 2 ore and 14 obsidian.
Blueprint 21: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 16 clay. Each geode robot costs 2 ore and 11 obsidian.
Blueprint 22: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 20 obsidian.
Blueprint 23: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 19 obsidian.
Blueprint 24: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 3 ore and 15 obsidian.
Blueprint 25: Each ore robot costs 2 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 10 obsidian.
Blueprint 26: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 20 clay. Each geode robot costs 2 ore and 10 obsidian.
Blueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 11 clay. Each geode robot costs 2 ore and 7 obsidian.
Blueprint 28: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 4 ore and 10 obsidian.
Blueprint 29: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 8 clay. Each geode robot costs 2 ore and 14 obsidian.
Blueprint 30: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 18 clay. Each geode robot costs 3 ore and 8 obsidian."""
}