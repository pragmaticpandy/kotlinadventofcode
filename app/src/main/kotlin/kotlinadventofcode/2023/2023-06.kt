// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2023`

import com.github.h0tk3y.betterParse.combinators.*
import com.github.h0tk3y.betterParse.grammar.*
import com.github.h0tk3y.betterParse.lexer.*
import com.github.h0tk3y.betterParse.parser.Parser
import kotlinadventofcode.Day
import java.math.BigInteger
import java.util.*

class `2023-06` : Day {

    override fun runPartOneNoUI(input: String): String {
        return parseRecords(input)
            .map { record -> record.findWinningPerformanceRange().count }
            .reduce(BigInteger::times)
            .toString()
    }

    override fun runPartTwoNoUI(input: String): String {
        return parseSingleRecord(input).findWinningPerformanceRange().count.toString()
    }

    data class PerformanceRange(val first: Performance, val last: Performance) {
        val count: BigInteger get() { return last.msHeld - first.msHeld + BigInteger.ONE }
    }

    data class Record(val ms: BigInteger, val mm: BigInteger) {

        fun findWinningPerformanceRange(): PerformanceRange {
            val winningPerformance = findRandomWinningPerformance()
            val first = findFirstWinningPerformance(Performance(BigInteger.ZERO, this), winningPerformance)
            val last = findLastWinningPerformance(winningPerformance, Performance(ms, this))
            return PerformanceRange(first, last)
        }

        private fun findRandomWinningPerformance(): Performance {
            while (true) {
                val performance = Performance(BigInteger(ms.bitLength(), Random()).mod(ms), this)
                if (performance.winning) {
                    return performance
                }
            }
        }

        private fun findLastWinningPerformance(lastKnownWinning: Performance, earliestKnownLosing: Performance): Performance {
            if (earliestKnownLosing.msHeld - lastKnownWinning.msHeld == BigInteger.ONE) {
                return lastKnownWinning
            }

            val middleHoldTime =
                (lastKnownWinning.msHeld + earliestKnownLosing.msHeld) / BigInteger.valueOf(2)

            val middlePerformance = Performance(middleHoldTime, this)

            return if (middlePerformance.winning) {
                findLastWinningPerformance(middlePerformance, earliestKnownLosing)
            } else {
                findLastWinningPerformance(lastKnownWinning, middlePerformance)
            }
        }

        private fun findFirstWinningPerformance(lastKnownLosing: Performance, earliestKnownWinning: Performance): Performance {
            if (earliestKnownWinning.msHeld - lastKnownLosing.msHeld == BigInteger.ONE) {
                return earliestKnownWinning
            }

            val middleHoldTime =
                (lastKnownLosing.msHeld + earliestKnownWinning.msHeld) / BigInteger.valueOf(2)

            val middlePerformance = Performance(middleHoldTime, this)

            return if (middlePerformance.winning) {
                findFirstWinningPerformance(lastKnownLosing, middlePerformance)
            } else {
                findFirstWinningPerformance(middlePerformance, earliestKnownWinning)
            }
        }
    }

    data class Performance(val msHeld: BigInteger, val record: Record) {
        val msTraveled = record.ms - msHeld
        val speed = msHeld
        val distance = msTraveled * speed
        val winning = distance > record.mm
    }

    private fun parseRecords(input: String): List<Record> {
        val (times, distances) = parseTimesAndDistances(input)
        return times.mapIndexed { i, time -> Record(time.toBigInteger(), distances[i].toBigInteger()) }
    }

    private fun parseTimesAndDistances(input: String): Pair<List<Int>, List<Int>> {
        val grammar = object : Grammar<Pair<List<Int>, List<Int>>>() {

            // tokens
            val newlineLit by literalToken("\n")
            val colonLit by literalToken(":")
            val spaceLit by literalToken(" ")
            val timeLit by literalToken("Time")
            val distanceLit by literalToken("Distance")
            val positiveIntRegex by regexToken("\\d+")

            // parsers
            val positiveInt by positiveIntRegex use { text.toInt() }
            val spaces by zeroOrMore(spaceLit)
            val intList by separatedTerms(positiveInt, spaces)
            val times by (skip(timeLit) and skip(colonLit) and skip(spaces) and intList)
            val distances by (skip(distanceLit) and skip(colonLit) and skip(spaces) and intList)

            override val rootParser by (times and skip(newlineLit) and distances) map { it.t1 to it.t2 }
        }

        return grammar.parseToEnd(input)
    }

    private fun parseSingleRecord(input: String): Record {
        val grammar = object : Grammar<Record>() {

            // tokens
            val newlineLit by literalToken("\n")
            val colonLit by literalToken(":")
            val spaceLit by literalToken(" ")
            val timeLit by literalToken("Time")
            val distanceLit by literalToken("Distance")
            val positiveIntRegex by regexToken("\\d+")

            // parsers
            val positiveInt by positiveIntRegex use { text }
            val spaces by zeroOrMore(spaceLit)
            val intString: Parser<String> by positiveInt and skip(spaces) and (parser(this::intString) or positiveInt) map { it.t1 + it.t2 }
            val bigInt by intString map { it.toBigInteger() }
            val time by skip(timeLit) and skip(colonLit) and skip(spaces) and bigInt
            val distance by skip(distanceLit) and skip(colonLit) and skip(spaces) and bigInt

            override val rootParser by (time and skip(newlineLit) and distance) map { Record(it.t1, it.t2) }
        }

        return grammar.parseToEnd(input)
    }

    override val defaultInput = """Time:        60     94     78     82
Distance:   475   2138   1015   1650"""
}