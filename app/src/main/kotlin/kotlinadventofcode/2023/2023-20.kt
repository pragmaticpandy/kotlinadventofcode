// Originally generated by the template in CodeDAO
package kotlinadventofcode.`2023`

import com.github.h0tk3y.betterParse.combinators.*
import com.github.h0tk3y.betterParse.grammar.*
import com.github.h0tk3y.betterParse.lexer.*
import kotlinadventofcode.Day
import kotlinadventofcode.UI.UI
import java.math.BigInteger

class `2023-20` : Day {
    override val year: Int = 2023
    override val day: Int = 20

    context(UI)
    override fun runPartOne(input: String): String {
        return runPartOne(input, 1_000)
    }

    context(UI)
    fun runPartOne(input: String, times: Int): String {
        var lowCount = 0.toBigInteger()
        var highCount = 0.toBigInteger()
        val modulesById = input.toModules().associateBy { it.id }
        repeat(times) {
            val queue = mutableListOf(Pulse("button", Strength.LOW, "broadcaster"))
            while (queue.isNotEmpty()) {
                val pulse = queue.removeAt(0)
                when (pulse.strength) {
                    Strength.HIGH -> highCount++
                    Strength.LOW -> lowCount++
                }

                modulesById[pulse.to]?.let {
                    queue.addAll(it.handlePulse(pulse))
                }
            }
        }

        return (lowCount * highCount).toString()
    }

    /**
     * Todo: this is a mess and hard coded to my inputs.
     * But essentially for my input the module that triggers rx is gf, which itself a conjunction
     * of four modules (kr, zs, kf, qk). The four of these all occasionally flip to HIGH in gf's
     * memory, and they do so in their own linear series. So the result is the product of each series slope.
     */
    context(UI)
    override fun runPartTwo(input: String): String {
        val modulesById = input.toModules().associateBy { it.id }
        var count = 0.toBigInteger()
        val krHighSeries = mutableListOf<BigInteger>()
        val zsHighSeries = mutableListOf<BigInteger>()
        val kfHighSeries = mutableListOf<BigInteger>()
        val qkHighSeries = mutableListOf<BigInteger>()

        val gfMemory = (modulesById["gf"]!! as Conjunction).memory
        while(true) {
            count++
            show("count", count.toString())
            val queue = mutableListOf(Pulse("button", Strength.LOW, "broadcaster"))
            while (queue.isNotEmpty()) {
                val pulse = queue.removeAt(0)
                if (pulse.to == "rx" && pulse.strength == Strength.LOW) {
                    return count.toString()
                }

                if (gfMemory["kr"] == Strength.HIGH && krHighSeries.lastOrNull() != count) {
                    krHighSeries.add(count)
                    show("kr high series", krHighSeries.joinToString(", "))
                }
                if (gfMemory["zs"] == Strength.HIGH && zsHighSeries.lastOrNull() != count) {
                    zsHighSeries.add(count)
                    show("zs high series", zsHighSeries.joinToString(", "))
                }
                if (gfMemory["kf"] == Strength.HIGH && kfHighSeries.lastOrNull() != count) {
                    kfHighSeries.add(count)
                    show("kf high series", kfHighSeries.joinToString(", "))
                }
                if (gfMemory["qk"] == Strength.HIGH && qkHighSeries.lastOrNull() != count) {
                    qkHighSeries.add(count)
                    show("qk high series", qkHighSeries.joinToString(", "))
                }

                if (krHighSeries.isNotEmpty() && zsHighSeries.isNotEmpty() && kfHighSeries.isNotEmpty() && qkHighSeries.isNotEmpty()) {
                    return (krHighSeries.first() * zsHighSeries.first() * kfHighSeries.first() * qkHighSeries.first()).toString()
                }

                modulesById[pulse.to]?.let {
                    queue.addAll(it.handlePulse(pulse))
                }
            }

            val gf = modulesById["gf"]!! as Conjunction
            show("gf", modulesById["gf"]!!)
            show("gf's inputs", modulesById["gf"]!!.inputs.map { modulesById[it]!! }.joinToString("\n"))
            show("gf's inputs' inputs", modulesById["gf"]!!.inputs.map { modulesById[it]!!.inputs.map { modulesById[it]!! } }.joinToString("\n"))
            gf.memory.forEach {
                if (it.value == Strength.HIGH) {
                    show("${it.key} was high in gf's memory at count", count)
                }
            }
        }
    }

    companion object {

        sealed class Module(val id: String, val inputs: List<String>, val outputs: List<String>) {
            abstract fun handlePulse(pulse: Pulse): List<Pulse>
        }

        class Broadcaster(id: String, inputs: List<String>, outputs: List<String>): Module(id, inputs, outputs) {
            override fun handlePulse(pulse: Pulse): List<Pulse> {
                return outputs.map { Pulse(id, pulse.strength, it) }
            }
        }

        class FlipFlop(id: String, inputs: List<String>, outputs: List<String>): Module(id, inputs, outputs) {
            private var off = true

            override fun handlePulse(pulse: Pulse): List<Pulse> {
                if (pulse.strength == Strength.HIGH) {
                    return listOf()
                } else {
                    off = !off
                    return outputs.map { Pulse(id, if (off) Strength.LOW else Strength.HIGH, it) }
                }
            }
        }

        class Conjunction(id: String, inputs: List<String>, outputs: List<String>): Module(id, inputs, outputs) {
            val memory: MutableMap<String, Strength> = inputs.associateWith { Strength.LOW }.toMutableMap()

            override fun handlePulse(pulse: Pulse): List<Pulse> {
                memory[pulse.from] = pulse.strength
                val outputPulse = if (memory.values.all { it == Strength.HIGH }) Strength.LOW else Strength.HIGH
                return outputs.map { Pulse(id, outputPulse, it) }
            }

            override fun toString(): String {
                return "Conjunction(id='$id', inputs=$inputs, outputs=$outputs, memory=$memory)"
            }
        }

        data class Pulse(val from: String, val strength: Strength, val to: String)

        enum class Strength {
            HIGH, LOW
        }

        sealed class ModuleDef(val id: String, val outputs: List<String>)
        class BroadcasterDef(id: String, outputs: List<String>): ModuleDef(id, outputs) {
            init {
                if (id != "broadcaster") error("Broadcaster must have id 'broadcaster', but was '$id'")
            }
        }

        class FlipFlopDef(id: String, outputs: List<String>): ModuleDef(id, outputs)
        class ConjunctionDef(id: String, outputs: List<String>): ModuleDef(id, outputs)

        fun String.toModules(): List<Module> {
            val grammar = object : Grammar<List<ModuleDef>>() {

                // tokens
                val newlineLit by literalToken("\n")
                val percentLit by literalToken("%")
                val ampersandLit by literalToken("&")
                val arrowLit by literalToken("->")
                val commaLit by literalToken(",")
                val spaceLit by literalToken(" ")
                val idRegex by regexToken("[a-z]+")

                // parsers
                val id by idRegex use { text }
                val idList by separatedTerms(id, commaLit and spaceLit)
                val idAndOutputs by (id and skip(spaceLit) and skip(arrowLit) and skip(spaceLit) and idList)
                val broadcaster by idAndOutputs map { (id, outputs) -> BroadcasterDef(id, outputs) }
                val flipFlop by skip(percentLit) and idAndOutputs map { (id, outputs) -> FlipFlopDef(id, outputs) }
                val conjunction by skip(ampersandLit) and idAndOutputs map { (id, outputs) -> ConjunctionDef(id, outputs) }
                val module by broadcaster or flipFlop or conjunction
                override val rootParser by separatedTerms(module, newlineLit)
            }

            val moduleDefs = grammar.parseToEnd(this)
            val inputsByOutput: MutableMap<String, MutableList<String>> = mutableMapOf()
            moduleDefs.forEach { moduleDef ->
                moduleDef.outputs.forEach { output ->
                    inputsByOutput.getOrPut(output) { mutableListOf() }.add(moduleDef.id)
                }
            }

            return moduleDefs.map { moduleDef ->
                when (moduleDef) {
                    is BroadcasterDef -> Broadcaster(moduleDef.id, inputsByOutput[moduleDef.id] ?: listOf(), moduleDef.outputs)
                    is FlipFlopDef -> FlipFlop(moduleDef.id, inputsByOutput[moduleDef.id] ?: error("No inputs for flip flop ${moduleDef.id}"), moduleDef.outputs)
                    is ConjunctionDef -> Conjunction(moduleDef.id, inputsByOutput[moduleDef.id] ?: error("No inputs for conjunction ${moduleDef.id}"), moduleDef.outputs)
                }
            }
        }
    }

    override val defaultInput = """%mh -> rz
%nd -> jx
%xt -> cx
%dp -> mh
%pz -> zg, bf
%rp -> jb, bf
%jb -> bf, kp
%rj -> xt, cx
%hg -> dl, bf
%pt -> gm, vv
%pf -> xk, qr
%cv -> jp, cx
%zg -> bb
%qn -> gm, bh
%kp -> pz
%kg -> gm, pt
%sl -> rp
%dz -> bf, dc
%hm -> cx, tz
%dc -> fk
%xk -> qr, sf
&kr -> gf
%bq -> qr, mg
%sf -> qr
&cx -> ff, vx, zs
%hr -> fq, gm
%ls -> lf, gm
%mf -> cx, sx
%vq -> gm
%sx -> cx, rj
&gm -> kg, kf, fq, nc, lf
%jx -> qr, zz
%tz -> mf, cx
%jp -> cx, kt
%bb -> hg, bf
%zz -> pf, qr
&qr -> dp, bq, nd, rz, mg, qk, mh
%nc -> gb
%kt -> hm, cx
%mg -> dp
%dl -> bf
&zs -> gf
&bf -> dz, zg, kr, sl, fk, kp, dc
%bh -> vq, gm
&kf -> gf
%fq -> qn
%vl -> vx, cx
&qk -> gf
%fk -> sl
%tj -> nd, qr
%gb -> ls, gm
%lf -> hr
%vx -> cv
%ff -> vl, cx
broadcaster -> kg, dz, ff, bq
%vv -> nc, gm
&gf -> rx
%rz -> tj"""
}